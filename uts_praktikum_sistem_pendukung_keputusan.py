# -*- coding: utf-8 -*-
"""UTS Praktikum Sistem Pendukung keputusan.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1NEWY3CqymNJxrKJEs0yfZNpe19_eR3-7
"""

import pandas as pd

df_mobil = pd.read_csv('/content/drive/MyDrive/Sistem Pendukung Keputusan/mobil.csv', sep=';')

df_mobil

df_mobil.dtypes

df_mobil.describe()

df_mobil = df_mobil.dropna()
print(df_mobil)

df_mobil = df_mobil.reset_index(drop=True)
print(df_mobil)

duplicated_rows = df_mobil[df_mobil.duplicated()]

print("Baris duplikat")
print(duplicated_rows)

df_mobil.describe()

"""Menentukan median dari kolom tenaga (HP)"""

median_value = df_mobil['Tenaga (HP)'].median()
print("Nilai Median Tenaga Mobil =" , median_value, "HP")

"""Memvisualisasikan Data-data yang ada menggunakan diagram"""

import matplotlib.pyplot as plt
import numpy as np

# Pengaturan parameter untuk diagram batang kelompok
bar_width = 0.15
index = np.arange(len(df_mobil['Mobil']))

plt.figure(figsize=(10, 6))

# Membuat diagram batang untuk setiap kriteria
plt.bar(index, df_mobil['Harga (Juta)'], width=bar_width, label='Harga (juta)', color='skyblue')
plt.bar(index + bar_width, df_mobil['Konsumsi BBM (km/L)'], width=bar_width, label='Konsumsi BBM (km/l)', color='salmon')
plt.bar(index + 2 * bar_width, df_mobil['Tenaga (HP)'], width=bar_width, label='Tenaga (HP)', color='lightgreen')
plt.bar(index + 3 * bar_width, df_mobil['Kapasitas Penumpang'], width=bar_width, label='Kapasitas Penumpang', color='darkblue')
plt.bar(index + 4 * bar_width, df_mobil['Bagasi (Liter)'], width=bar_width, label='Bagasi (Liter)', color='darkred')

# Menambahkan detail ke plot
plt.title('Perbandingan Harga, Konsumsi BBM, Tenaga, Kapasitas Penumpang, dan Bagasi untuk Berbagai Merek Mobil')
plt.xlabel('Merek Mobil')
plt.ylabel('Nilai')
plt.xticks(index + bar_width, df_mobil['Mobil'])
plt.xticks(rotation=45, ha='right')
plt.legend(title="Kriteria")

plt.show()

"""Menentukan Mobil Terbaik menggunakan teknik MOORA"""

label = [0, 0, 1, 1, 1, ]

alternatif = df_mobil['Mobil'].values

import numpy as np

matrix_data=df_mobil.drop(columns=['Mobil']).values

print (matrix_data)

# Pada modul ini akan diterapkan normalisasi matrix sesuai dengan persamaan
# Kita akan membuat fungsi yang akan menerima paramater berupa array 2d
import math

def normalization(matrix):
    # Transpose Decision Matrix
    matrix = matrix.transpose()
    row_values = []
    norm_matrix = []

    for i in range(matrix.shape[0]): # Looping per baris (kriteria)
        # Menghitung sum tiap x_{ij}^2
        sum_row = sum([pow(x,2) for x in matrix[i]])

        for j in range(matrix[i].shape[0]): # Looping per kolom (alternatif)
            # membangi nilai asli x_{ij} dengan hasil akar
            r_value = matrix[i][j] / math.sqrt(sum_row)

            # Masukkan hasil normalisasi ke list tiap baris
            row_values.append(r_value)

        #Masukkan hasil normalisasi per baris ke matrix normalisasi
        norm_matrix.append(row_values)

        #Kosongkan list normalisasi perbaris
        row_values = []

    # Ubah dalam bentuk numpy array
    norm_matrix = np.asarray(norm_matrix)

    # Return dalam bentuk transporse agar kembali ke format awal
    return norm_matrix.transpose()

# Test fungsi normalisasi
# Assign matrix_data to init_matrix to use it in normalization function
init_matrix = matrix_data
n_matrix = normalization(init_matrix)

# Cetak hasil normalisasi
print(n_matrix)

# Kalkulasi skor normalisasi terbobot

# Bobot untuk Kriteria C1, C2, C3, C4, C5, dan C6
c_weights = np.array([0.05, 0.05, 0.3, 0.3, 0.3])

# Fungsi untuk kalkulasi matrix terbobot. Paramter yang diperlukan adalah nilai ternormalisasi dan bobot
# Untuk mempermudah perhitungan, lakukan operasi transpose pada matrix ternormalisasi.
# Ingat! Kriteria adalah baris, alternatif adalah kolom setelah proses transpose
def weighted_normalization(n_matrix, c_weights):
    # Buat salinan nilai ternormalisasi dan transpose
    norm_weighted = n_matrix.transpose()

    for i in range(c_weights.shape[0]): # Looping tiap kriteria
        # Kalkulasi normalisasi terbobot
        norm_weighted[i] = [r * c_weights[i] for r in norm_weighted[i]]

    # Ubah ke bentuk numpy array
    norm_weighted = np.asarray(norm_weighted)

    # Return ke dalam format matrix semula
    return norm_weighted.transpose()

# Test fungsi pembobotan
w_matrix = weighted_normalization(n_matrix, c_weights)

# Cetak hasil
print(w_matrix)

# Implementasi Menghitung Nilai
def optimize_value(w_matrix, label):
    y_values = []

    for i in range(w_matrix.shape[0]):
        max_val = []
        min_val = []

        for j in range(w_matrix[i].shape[0]):
            # Hitung benefit
            if label[j] == 1:
                max_val.append(w_matrix[i][j])
            # Hitung cost
            else:
                min_val.append(w_matrix[i][j])

        y = sum(max_val) - sum(min_val)
        y_values.append(y)

    return np.asarray(y_values)

# Test fungsi nilai optimasi
result = optimize_value(w_matrix, label)

print(result)

# Import Libary
import numpy as np
import math

# Data Studi Kasus
label = [0, 0, 1, 1, 1, ]
matrix_data = df_mobil.drop(columns=['Mobil']).values
c_weights = np.array([0.05, 0.05, 0.3, 0.3, 0.3])

'''
Fungsi-fungsi perhitungan MOORA
'''


# Kita akan membuat fungsi yang akan menerima paramater berupa array 2d

def normalization(matrix):
    # Transpose Decision Matrix
    matrix = matrix.transpose()
    row_values = []
    norm_matrix = []

    for i in range(matrix.shape[0]): # Looping per baris (kriteria)
        # Menghitung sum tiap x_{ij}^2
        sum_row = sum([pow(x,2) for x in matrix[i]])

        for j in range(matrix[i].shape[0]): # Looping per kolom (alternatif)
            # membangi nilai asli x_{ij} dengan hasil akar
            r_value = matrix[i][j] / math.sqrt(sum_row)

            # Masukkan hasil normalisasi ke list tiap baris
            row_values.append(r_value)

        #Masukkan hasil normalisasi per baris ke matrix normalisasi
        norm_matrix.append(row_values)

        #Kosongkan list normalisasi perbaris
        row_values = []

    # Ubah dalam bentuk numpy array
    norm_matrix = np.asarray(norm_matrix)

    # Return dalam bentuk transporse agar kembali ke format awal
    return norm_matrix.transpose()


# Fungsi untuk kalkulasi matrix terbobot. Paramter yang diperlukan adalah nilai ternormalisasi dan bobot
# Untuk mempermudah perhitungan, lakukan operasi transpose pada matrix ternormalisasi.
# Ingat! Kriteria adalah baris, alternatif adalah kolom setelah proses transpose
def weighted_normalization(n_matrix, c_weights):
    # Buat salinan nilai ternormalisasi dan transpose
    norm_weighted = n_matrix.transpose()

    for i in range(c_weights.shape[0]): # Looping tiap kriteria
        # Kalkulasi normalisasi terbobot
        norm_weighted[i] = [r * c_weights[i] for r in norm_weighted[i]]

    # Ubah ke bentuk numpy array
    norm_weighted = np.asarray(norm_weighted)

    # Return ke dalam format matrix semula
    return norm_weighted.transpose()


# Implementasi Menghitung Nilai Optimasi
def optimize_value(w_matrix, label):
    y_values = []

    for i in range(w_matrix.shape[0]):
        max_val = []
        min_val = []

        for j in range(w_matrix[i].shape[0]):
            # Hitung benefit
            if label[j] == 1:
                max_val.append(w_matrix[i][j])
            # Hitung cost
            else:
                min_val.append(w_matrix[i][j])

        y = sum(max_val) - sum(min_val)
        y_values.append(y)

    return np.asarray(y_values)

#Posisi / index nilai terbesar (ranking 1)
indexRank1 = np.argmax(result)
# Kesimpulan / keputusan
print(f'Merk mobil dengan nilai tertinggi adalah A{indexRank1 + 1}, yaitu {alternatif[indexRank1]}')